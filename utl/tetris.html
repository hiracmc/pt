<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>単語帳web v1.0.2</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            font-family: Arial, sans-serif;
        }
        .game-container {
            display: flex;
            gap: 20px;
            align-items: flex-start;
        }
        .side-panel {
            color: white;
            width: 120px;
        }
        .hold-box, .next-box {
            border: 2px solid #444;
            padding: 10px;
            margin-bottom: 20px;
            background-color: #111;
        }
        .hold-box h3, .next-box h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            text-align: center;
        }
        .preview-canvas {
            display: block;
            margin: 0 auto;
        }
        .game-board {
            position: relative;
        }
        #gameCanvas {
            border: 2px solid #444;
            background-color: #000;
            display: block;
        }
        .score-info {
            color: white;
            font-size: 14px;
        }
        .score-info div {
            margin-bottom: 5px;
        }
        .game-over-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }
        .game-over-screen {
            background-color: #333;
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            color: white;
        }
        .game-over-screen h2 {
            margin-top: 0;
            color: #ff4444;
            font-size: 24px;
        }
        .game-over-screen .stats {
            margin: 20px 0;
            font-size: 16px;
        }
        .game-over-screen .stats div {
            margin: 5px 0;
        }
        .retry-button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
        }
        .retry-button:hover {
            background-color: #45a049;
        }
        .ai-control {
            margin-top: 20px;
        }
        .ai-button {
            background-color: #2196F3;
            color: white;
            border: none;
            padding: 8px 16px;
            font-size: 14px;
            border-radius: 5px;
            cursor: pointer;
            width: 100%;
        }
        .ai-button:hover {
            background-color: #1976D2;
        }
        .ai-button.active {
            background-color: #4CAF50;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="side-panel">
            <div class="hold-box">
                <h3>HOLD</h3>
                <canvas id="holdCanvas" width="80" height="80" class="preview-canvas"></canvas>
            </div>
            <div class="score-info">
                <div>SCORE: <span id="score">0</span></div>
                <div>LEVEL: <span id="level">1</span></div>
                <div>LINES: <span id="lines">0</span></div>
            </div>
        </div>
        
        <div class="game-board">
            <canvas id="gameCanvas" width="300" height="600"></canvas>
        </div>
        
        <div class="side-panel">
            <div class="next-box">
                <h3>NEXT</h3>
                <canvas id="nextCanvas" width="80" height="320" class="preview-canvas"></canvas>
            </div>
            <div class="ai-control">
                <button id="aiToggle" class="ai-button">CPU: OFF</button>
            </div>
        </div>
    </div>

    <div class="game-over-overlay" id="gameOverOverlay">
        <div class="game-over-screen">
            <h2>GAME OVER</h2>
            <div class="stats">
                <div>Final Score: <span id="finalScore">0</span></div>
                <div>Level Reached: <span id="finalLevel">1</span></div>
                <div>Lines Cleared: <span id="finalLines">0</span></div>
            </div>
            <button class="retry-button" onclick="retryGame()">RETRY</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');
        const holdCanvas = document.getElementById('holdCanvas');
        const holdContext = holdCanvas.getContext('2d');
        const nextCanvas = document.getElementById('nextCanvas');
        const nextContext = nextCanvas.getContext('2d');

        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 40;
        const VISIBLE_HEIGHT = 20;
        const CELL_SIZE = 30;

        const tetrominoShapes = {
            I: [
                [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
                [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]],
                [[0,0,0,0], [0,0,0,0], [1,1,1,1], [0,0,0,0]],
                [[0,1,0,0], [0,1,0,0], [0,1,0,0], [0,1,0,0]]
            ],
            O: [
                [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,1,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]]
            ],
            T: [
                [[0,1,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,0,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]],
                [[0,0,0,0], [1,1,1,0], [0,1,0,0], [0,0,0,0]],
                [[0,1,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]
            ],
            S: [
                [[0,1,1,0], [1,1,0,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,0,0], [0,1,1,0], [0,0,1,0], [0,0,0,0]],
                [[0,0,0,0], [0,1,1,0], [1,1,0,0], [0,0,0,0]],
                [[1,0,0,0], [1,1,0,0], [0,1,0,0], [0,0,0,0]]
            ],
            Z: [
                [[1,1,0,0], [0,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,0,1,0], [0,1,1,0], [0,1,0,0], [0,0,0,0]],
                [[0,0,0,0], [1,1,0,0], [0,1,1,0], [0,0,0,0]],
                [[0,1,0,0], [1,1,0,0], [1,0,0,0], [0,0,0,0]]
            ],
            J: [
                [[1,0,0,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,1,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]],
                [[0,0,0,0], [1,1,1,0], [0,0,1,0], [0,0,0,0]],
                [[0,1,0,0], [0,1,0,0], [1,1,0,0], [0,0,0,0]]
            ],
            L: [
                [[0,0,1,0], [1,1,1,0], [0,0,0,0], [0,0,0,0]],
                [[0,1,0,0], [0,1,0,0], [0,1,1,0], [0,0,0,0]],
                [[0,0,0,0], [1,1,1,0], [1,0,0,0], [0,0,0,0]],
                [[1,1,0,0], [0,1,0,0], [0,1,0,0], [0,0,0,0]]
            ]
        };

        const tetrominoColors = {
            I: '#00FFFF',
            O: '#FFFF00', 
            T: '#800080',
            S: '#00FF00',
            Z: '#FF0000',
            J: '#0000FF',
            L: '#FFA500'
        };

        const spawnPositions = {
            I: { x: 3, y: 18 },
            O: { x: 4, y: 18 },
            T: { x: 3, y: 19 },
            S: { x: 3, y: 19 },
            Z: { x: 3, y: 19 },
            J: { x: 3, y: 19 },  
            L: { x: 3, y: 19 }
        };

        let gameBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
        let currentPiece = null;
        let currentX = 0;
        let currentY = 0;
        let currentRotation = 0;
        let heldPiece = null;
        let canHold = true;
        let nextPieces = [];
        let tetrominoBag = [];
        let score = 0;
        let level = 1;
        let linesCleared = 0;
        let dropTimer = 0;
        let dropInterval = 1000;
        let lockDelay = 0;
        let lockDelayMax = 500;
        let moveResetCounter = 0;
        let lastTime = 0;
        let gameRunning = true;

        const keys = {
            left: false,
            right: false,
            down: false,
            up: false,
            z: false,
            x: false,
            c: false,
            shift: false,
            f: false,
            i: false
        };

        let dasTimer = 0;
        let dasDelay = 90;
        let arrRate = 1;
        let dasDirection = 0;
        let isFirstDasMove = true;

        let screenShakeX = 0;
        let screenShakeY = 0;
        let shakeTimer = 0;
        let shakeDuration = 0;
        let shakeIntensity = 0;

        let dropAnimation = 0;
        let dropAnimationTimer = 0;

        let rotationEffect = 0;
        let rotationTimer = 0;
        let rotationDuration = 600;

        let lastMovedBeforeLock = false;
        let tSpinText = '';
        let tSpinTimer = 0;
        let tSpinDuration = 2000;

        let perfectClearText = '';
        let perfectClearTimer = 0;
        let perfectClearDuration = 3000;

        let consecutiveLineClears = 0;
        let lastLineClearTime = 0;
        let comboActive = false;
        let aiMode = false;
        let aiMoveTimer = 0;
        let aiMoveDelay = 200;

        function shuffleBag() {
            const pieces = ['I', 'O', 'T', 'S', 'Z', 'J', 'L'];
            for (let i = pieces.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
            }
            return pieces;
        }

        function getNextPiece() {
            if (tetrominoBag.length === 0) {
                tetrominoBag = shuffleBag();
            }
            return tetrominoBag.pop();
        }

        function initializeGame() {
            gameBoard = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
            nextPieces = [];
            tetrominoBag = [];
            score = 0;
            level = 1;
            linesCleared = 0;
            dropInterval = 1000;
            consecutiveLineClears = 0;
            comboActive = false;
            heldPiece = null;
            canHold = true;
            gameRunning = true;
            document.getElementById('gameOverOverlay').style.display = 'none';
            
            for (let i = 0; i < 7; i++) {
                nextPieces.push(getNextPiece());
            }
            spawnNewPiece();
        }

        function spawnNewPiece() {
            currentPiece = nextPieces.shift();
            nextPieces.push(getNextPiece());
            
            const spawnPos = spawnPositions[currentPiece];
            currentX = spawnPos.x;
            currentY = spawnPos.y;
            currentRotation = 0;
            canHold = true;
            lockDelay = 0;
            moveResetCounter = 0;
            lastMovedBeforeLock = false;

            if (isCollision(currentPiece, currentX, currentY, currentRotation)) {
                gameOver();
            }
        }

        function isCollision(piece, x, y, rotation) {
            const shape = tetrominoShapes[piece][rotation];
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    if (shape[row][col]) {
                        const newX = x + col;
                        const newY = y + row;
                        if (newX < 0 || newX >= BOARD_WIDTH || newY >= BOARD_HEIGHT || 
                            (newY >= 0 && gameBoard[newY][newX])) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function getSRSKickTests(piece, fromRotation, toRotation) {
            if (piece === 'O') {
                return [[0, 0]];
            }

            const iKickTests = {
                '0->1': [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
                '1->0': [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
                '1->2': [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]],
                '2->1': [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
                '2->3': [[0, 0], [2, 0], [-1, 0], [2, -1], [-1, 2]],
                '3->2': [[0, 0], [-2, 0], [1, 0], [-2, 1], [1, -2]],
                '3->0': [[0, 0], [1, 0], [-2, 0], [1, 2], [-2, -1]],
                '0->3': [[0, 0], [-1, 0], [2, 0], [-1, -2], [2, 1]]
            };

            const standardKickTests = {
                '0->1': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '1->0': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
                '1->2': [[0, 0], [1, 0], [1, 1], [0, -2], [1, -2]],
                '2->1': [[0, 0], [-1, 0], [-1, -1], [0, 2], [-1, 2]],
                '2->3': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]],
                '3->2': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '3->0': [[0, 0], [-1, 0], [-1, 1], [0, -2], [-1, -2]],
                '0->3': [[0, 0], [1, 0], [1, -1], [0, 2], [1, 2]]
            };

            const key = `${fromRotation}->${toRotation}`;
            
            if (piece === 'I') {
                return iKickTests[key] || [[0, 0]];
            } else {
                return standardKickTests[key] || [[0, 0]];
            }
        }

        function tryRotate(direction) {
            const newRotation = direction === 1 ? 
                (currentRotation + 1) % 4 : 
                (currentRotation + 3) % 4;

            const kickTests = getSRSKickTests(currentPiece, currentRotation, newRotation);

            for (const [offsetX, offsetY] of kickTests) {
                const testX = currentX + offsetX;
                const testY = currentY + offsetY;

                if (!isCollision(currentPiece, testX, testY, newRotation)) {
                    currentX = testX;
                    currentY = testY;
                    currentRotation = newRotation;
                    resetLockDelay();
                    
                    if (currentPiece === 'T' && checkTSpinPotential()) {
                        startRotationEffect(direction);
                    }
                    
                    lastMovedBeforeLock = true;
                    
                    return true;
                }
            }
            return false;
        }

        function try180Rotate() {
            const newRotation = (currentRotation + 2) % 4;
            
            const kickTests180 = [
                [0, 0],
                [0, 1],
                [1, 1],
                [-1, 1],
                [1, 0],
                [-1, 0],
                [0, -1],
                [1, -1],
                [-1, -1]
            ];

            for (const [offsetX, offsetY] of kickTests180) {
                const testX = currentX + offsetX;
                const testY = currentY + offsetY;

                if (!isCollision(currentPiece, testX, testY, newRotation)) {
                    currentX = testX;
                    currentY = testY;
                    currentRotation = newRotation;
                    resetLockDelay();
                    
                    if (currentPiece === 'T' && checkTSpinPotential()) {
                        startRotationEffect(2);
                    }
                    
                    lastMovedBeforeLock = true;
                    
                    return true;
                }
            }
            return false;
        }

        function checkTSpinPotential() {
            const centerX = currentX + 1;
            const centerY = currentY + 1;

            const corners = [
                [centerX - 1, centerY - 1],
                [centerX + 1, centerY - 1],
                [centerX - 1, centerY + 1],
                [centerX + 1, centerY + 1]
            ];

            let filledCorners = 0;
            for (const [x, y] of corners) {
                if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT || 
                    (y >= 0 && gameBoard[y][x] !== 0)) {
                    filledCorners++;
                }
            }

            return filledCorners >= 3;
        }

        function resetLockDelay() {
            if (moveResetCounter < 15) {
                lockDelay = 0;
                moveResetCounter++;
            }
        }

        function movePiece(deltaX, deltaY) {
            if (!isCollision(currentPiece, currentX + deltaX, currentY + deltaY, currentRotation)) {
                currentX += deltaX;
                currentY += deltaY;
                if (deltaY === 0) {
                    resetLockDelay();
                    if (currentPiece === 'T') {
                        lastMovedBeforeLock = false;
                    }
                }
                return true;
            }
            return false;
        }

        function hardDrop() {
            let dropDistance = 0;
            while (!isCollision(currentPiece, currentX, currentY + dropDistance + 1, currentRotation)) {
                dropDistance++;
            }
            currentY += dropDistance;
            score += dropDistance * 2;
            lockPiece();
        }

        function lockPiece() {
            const shape = tetrominoShapes[currentPiece][currentRotation];
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    if (shape[row][col]) {
                        const x = currentX + col;
                        const y = currentY + row;
                        if (y >= 0 && y < BOARD_HEIGHT && x >= 0 && x < BOARD_WIDTH) {
                            gameBoard[y][x] = currentPiece;
                        }
                    }
                }
            }
            startDropAnimation();
            
            const isTSpin = checkTSpin();
            const linesBeforeClear = countFullLines();
            clearLines(isTSpin);
            
            if (linesBeforeClear === 0) {
                const currentTime = Date.now();
                if (currentTime - lastLineClearTime > 5000) {
                    consecutiveLineClears = 0;
                    comboActive = false;
                }
            }
            
            spawnNewPiece();
        }

        function countFullLines() {
            let count = 0;
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                if (gameBoard[y].every(cell => cell !== 0)) {
                    count++;
                }
            }
            return count;
        }

        function clearLines(isTSpin = false) {
            let linesFound = [];
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                if (gameBoard[y].every(cell => cell !== 0)) {
                    linesFound.push(y);
                }
            }

            if (linesFound.length > 0) {
                const currentTime = Date.now();
                
                if (currentTime - lastLineClearTime < 5000) {
                    consecutiveLineClears++;
                    comboActive = true;
                } else {
                    consecutiveLineClears = 1;
                    comboActive = false;
                }
                lastLineClearTime = currentTime;

                linesFound.sort((a, b) => b - a);
                
                for (let y of linesFound) {
                    gameBoard.splice(y, 1);
                }
                
                for (let i = 0; i < linesFound.length; i++) {
                    gameBoard.unshift(Array(BOARD_WIDTH).fill(0));
                }

                linesCleared += linesFound.length;
                
                const isPerfectClear = checkPerfectClear();
                
                let lineScore = [0, 40, 100, 300, 1200][linesFound.length] * level;
                if (isTSpin) {
                    const tSpinBonus = [0, 800, 1200, 1600][linesFound.length] * level;
                    lineScore = tSpinBonus;
                    
                    const lineNames = ['', 'SINGLE', 'DOUBLE', 'TRIPLE'];
                    tSpinText = `T-SPIN ${lineNames[linesFound.length]}`;
                    tSpinTimer = 0;
                }
                
                if (isPerfectClear) {
                    const perfectClearBonus = calculatePerfectClearBonus(linesFound.length, isTSpin);
                    lineScore += perfectClearBonus;
                    
                    perfectClearText = 'PERFECT CLEAR!';
                    perfectClearTimer = 0;
                    
                    startScreenShake(15, 1000);
                    playPerfectClearSound();
                }
                
                score += lineScore;

                level = Math.floor(linesCleared / 10) + 1;
                dropInterval = Math.max(50, 1000 - (level - 1) * 50);

                if (!isPerfectClear) {
                    startScreenShake(linesFound.length * 2, 300);
                }
                
                if (!isPerfectClear) {
                    playLineClearSound(linesFound.length);
                }
            } else {
                const currentTime = Date.now();
                if (currentTime - lastLineClearTime > 5000) {
                    consecutiveLineClears = 0;
                    comboActive = false;
                }
            }
        }

        function startScreenShake(intensity, duration) {
            shakeIntensity = intensity;
            shakeDuration = duration;
            shakeTimer = 0;
        }

        function updateScreenShake(deltaTime) {
            if (shakeTimer < shakeDuration) {
                shakeTimer += deltaTime;
                const progress = shakeTimer / shakeDuration;
                const currentIntensity = shakeIntensity * (1 - progress);
                
                screenShakeX = (Math.random() - 0.5) * currentIntensity;
                screenShakeY = (Math.random() - 0.5) * currentIntensity;
            } else {
                screenShakeX = 0;
                screenShakeY = 0;
            }
        }

        function startDropAnimation() {
            dropAnimation = 8;
            dropAnimationTimer = 0;
        }

        function updateDropAnimation(deltaTime) {
            if (dropAnimation > 0) {
                dropAnimationTimer += deltaTime;
                if (dropAnimationTimer >= 50) {
                    dropAnimation--;
                    dropAnimationTimer = 0;
                }
            }
        }

        function startRotationEffect(direction) {
            rotationEffect = direction * 2.5;
            rotationTimer = 0;
        }

        function updateRotationEffect(deltaTime) {
            if (Math.abs(rotationEffect) > 0.1) {
                rotationTimer += deltaTime;
                const progress = Math.min(rotationTimer / rotationDuration, 1);
                const easeOut = 1 - Math.pow(1 - progress, 3);
                rotationEffect = rotationEffect * (1 - easeOut);
            } else {
                rotationEffect = 0;
            }
        }

        function checkTSpin() {
            if (currentPiece !== 'T' || !lastMovedBeforeLock) {
                return false;
            }

            const centerX = currentX + 1;
            const centerY = currentY + 1;

            const corners = [
                [centerX - 1, centerY - 1],
                [centerX + 1, centerY - 1],
                [centerX - 1, centerY + 1],
                [centerX + 1, centerY + 1]
            ];

            let filledCorners = 0;
            for (const [x, y] of corners) {
                if (x < 0 || x >= BOARD_WIDTH || y < 0 || y >= BOARD_HEIGHT || 
                    (y >= 0 && gameBoard[y][x] !== 0)) {
                    filledCorners++;
                }
            }

            return filledCorners >= 3;
        }

        function playLineClearSound(lineCount) {
            const baseFrequency = 261.63;
            const semitoneRatio = Math.pow(2, 1/12);
            const pitch = Math.min(consecutiveLineClears - 1, 11);
            const frequency = baseFrequency * Math.pow(semitoneRatio, pitch);

            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                oscillator.type = 'sine';

                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.5);
            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function checkPerfectClear() {
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (gameBoard[y][x] !== 0) {
                        return false;
                    }
                }
            }
            return true;
        }

        function calculatePerfectClearBonus(linesCleared, isTSpin) {
            let bonus = 0;
            
            if (linesCleared === 1) {
                bonus = isTSpin ? 1200 : 800;
            } else if (linesCleared === 2) {
                bonus = isTSpin ? 2000 : 1200;
            } else if (linesCleared === 3) {
                bonus = isTSpin ? 2600 : 1800;
            } else if (linesCleared === 4) {
                bonus = 2000;
            }
            
            return bonus * level;
        }

        function playPerfectClearSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                const frequencies = [523.25, 659.25, 783.99];
                const oscillators = [];
                const gainNodes = [];

                frequencies.forEach((freq, index) => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine';

                    gainNode.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 1.5);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 1.5);

                    oscillators.push(oscillator);
                    gainNodes.push(gainNode);
                });

                setTimeout(() => {
                    const sparkleFreqs = [1046.5, 1318.5, 1567.98];
                    sparkleFreqs.forEach((freq, index) => {
                        setTimeout(() => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            
                            osc.frequency.setValueAtTime(freq, audioContext.currentTime);
                            osc.type = 'sine';
                            
                            gain.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                            
                            osc.start(audioContext.currentTime);
                            osc.stop(audioContext.currentTime + 0.3);
                        }, index * 100);
                    });
                }, 200);

            } catch (e) {
                console.log('Audio not supported');
            }
        }

        function holdPiece() {
            if (!canHold) return;

            if (heldPiece === null) {
                heldPiece = currentPiece;
                spawnNewPiece();
            } else {
                const temp = currentPiece;
                currentPiece = heldPiece;
                heldPiece = temp;

                const spawnPos = spawnPositions[currentPiece];
                currentX = spawnPos.x;
                currentY = spawnPos.y;
                currentRotation = 0;
                lockDelay = 0;
                moveResetCounter = 0;
            }
            canHold = false;
        }

        function gameOver() {
            gameRunning = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalLevel').textContent = level;
            document.getElementById('finalLines').textContent = linesCleared;
            document.getElementById('gameOverOverlay').style.display = 'flex';
        }

        function retryGame() {
            initializeGame();
        }

        function toggleAI() {
            aiMode = !aiMode;
            const button = document.getElementById('aiToggle');
            if (aiMode) {
                button.textContent = 'CPU: ON';
                button.classList.add('active');
            } else {
                button.textContent = 'CPU: OFF';
                button.classList.remove('active');
            }
        }

        function evaluatePosition(piece, x, y, rotation, board) {
            const testBoard = board.map(row => [...row]);
            const shape = tetrominoShapes[piece][rotation];
            
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    if (shape[row][col]) {
                        const boardX = x + col;
                        const boardY = y + row;
                        if (boardY >= 0 && boardY < BOARD_HEIGHT && boardX >= 0 && boardX < BOARD_WIDTH) {
                            testBoard[boardY][boardX] = piece;
                        }
                    }
                }
            }

            let score = 0;
            let completedLines = 0;
            
            for (let y = 0; y < BOARD_HEIGHT; y++) {
                if (testBoard[y].every(cell => cell !== 0)) {
                    completedLines++;
                }
            }

            let aggregateHeight = 0;
            let holes = 0;
            let bumpiness = 0;
            let heights = [];

            for (let x = 0; x < BOARD_WIDTH; x++) {
                let height = 0;
                let foundBlock = false;
                
                for (let y = 0; y < BOARD_HEIGHT; y++) {
                    if (testBoard[y][x] !== 0) {
                        height = BOARD_HEIGHT - y;
                        foundBlock = true;
                        break;
                    }
                }
                
                heights.push(height);
                aggregateHeight += height;

                if (foundBlock) {
                    for (let y = BOARD_HEIGHT - height; y < BOARD_HEIGHT; y++) {
                        if (testBoard[y][x] === 0) {
                            holes++;
                        }
                    }
                }
            }

            for (let i = 0; i < heights.length - 1; i++) {
                bumpiness += Math.abs(heights[i] - heights[i + 1]);
            }

            const isTSpin = piece === 'T' && checkTSpinForAI(piece, x, y, rotation, testBoard);
            
            if (completedLines === 1) {
                score += 300;
            } else if (completedLines === 2) {
                score += 300;
            } else if (completedLines === 3) {
                score += 350;
            } else if (completedLines === 4) {
                score += 3000;
            }
            
            if (isTSpin) {
                score += completedLines * 2000;
            }
            
            score -= aggregateHeight * 0.5;
            score -= holes * 150;
            score -= bumpiness * 0.2;

            return score;
        }

        function checkTSpinForAI(piece, x, y, rotation, board) {
            if (piece !== 'T') return false;

            const centerX = x + 1;
            const centerY = y + 1;

            const corners = [
                [centerX - 1, centerY - 1],
                [centerX + 1, centerY - 1],
                [centerX - 1, centerY + 1],
                [centerX + 1, centerY + 1]
            ];

            let filledCorners = 0;
            for (const [cx, cy] of corners) {
                if (cx < 0 || cx >= BOARD_WIDTH || cy < 0 || cy >= BOARD_HEIGHT || 
                    (cy >= 0 && board[cy][cx] !== 0)) {
                    filledCorners++;
                }
            }

            return filledCorners >= 3;
        }

        function findBestMove() {
            let bestScore = -Infinity;
            let bestMove = null;

            for (let rotation = 0; rotation < 4; rotation++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    let y = 0;
                    while (y < BOARD_HEIGHT && !isCollision(currentPiece, x, y, rotation)) {
                        y++;
                    }
                    y--;

                    if (y >= 0 && !isCollision(currentPiece, x, y, rotation)) {
                        const score = evaluatePosition(currentPiece, x, y, rotation, gameBoard);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = { x, y, rotation };
                        }
                    }
                }
            }

            return bestMove;
        }

        function executeAIMove() {
            const bestMove = findBestMove();
            if (!bestMove) return;

            while (currentRotation !== bestMove.rotation) {
                tryRotate(1);
            }

            while (currentX !== bestMove.x) {
                if (currentX < bestMove.x) {
                    movePiece(1, 0);
                } else {
                    movePiece(-1, 0);
                }
            }

            hardDrop();
        }

        function drawCell(ctx, x, y, size, color) {
            ctx.fillStyle = color;
            ctx.fillRect(x, y, size, size);
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1;
            ctx.strokeRect(x, y, size, size);
        }

        function drawPiece(ctx, piece, x, y, size, rotation = 0) {
            const shape = tetrominoShapes[piece][rotation];
            const color = tetrominoColors[piece];
            
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    if (shape[row][col]) {
                        drawCell(ctx, x + col * size, y + row * size, size, color);
                    }
                }
            }
        }

        function drawGhostPiece() {
            let ghostY = currentY;
            while (!isCollision(currentPiece, currentX, ghostY + 1, currentRotation)) {
                ghostY++;
            }

            if (ghostY !== currentY) {
                const shape = tetrominoShapes[currentPiece][currentRotation];
                const baseColor = tetrominoColors[currentPiece];
                
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (shape[row][col]) {
                            const x = currentX + col;
                            const y = ghostY + row;
                            if (y >= BOARD_HEIGHT - VISIBLE_HEIGHT && y < BOARD_HEIGHT) {
                                context.fillStyle = baseColor + '40';
                                context.fillRect(
                                    x * CELL_SIZE, 
                                    (y - (BOARD_HEIGHT - VISIBLE_HEIGHT)) * CELL_SIZE + dropAnimation, 
                                    CELL_SIZE, 
                                    CELL_SIZE
                                );
                                context.strokeStyle = baseColor + '80';
                                context.lineWidth = 2;
                                context.strokeRect(
                                    x * CELL_SIZE, 
                                    (y - (BOARD_HEIGHT - VISIBLE_HEIGHT)) * CELL_SIZE + dropAnimation, 
                                    CELL_SIZE, 
                                    CELL_SIZE
                                );
                            }
                        }
                    }
                }
            }
        }

        function render() {
            context.save();
            context.translate(canvas.width / 2, canvas.height / 2);
            context.rotate(rotationEffect * Math.PI / 180);
            context.translate(-canvas.width / 2 + screenShakeX, -canvas.height / 2 + screenShakeY);
            
            context.clearRect(-screenShakeX, -screenShakeY, canvas.width + Math.abs(screenShakeX) * 2, canvas.height + Math.abs(screenShakeY) * 2);

            for (let y = BOARD_HEIGHT - VISIBLE_HEIGHT; y < BOARD_HEIGHT; y++) {
                for (let x = 0; x < BOARD_WIDTH; x++) {
                    if (gameBoard[y][x]) {
                        drawCell(
                            context,
                            x * CELL_SIZE,
                            (y - (BOARD_HEIGHT - VISIBLE_HEIGHT)) * CELL_SIZE + dropAnimation,
                            CELL_SIZE,
                            tetrominoColors[gameBoard[y][x]]
                        );
                    }
                }
            }

            if (currentPiece) {
                drawGhostPiece();
                
                const shape = tetrominoShapes[currentPiece][currentRotation];
                for (let row = 0; row < 4; row++) {
                    for (let col = 0; col < 4; col++) {
                        if (shape[row][col]) {
                            const x = currentX + col;
                            const y = currentY + row;
                            if (y >= BOARD_HEIGHT - VISIBLE_HEIGHT && y < BOARD_HEIGHT) {
                                drawCell(
                                    context,
                                    x * CELL_SIZE,
                                    (y - (BOARD_HEIGHT - VISIBLE_HEIGHT)) * CELL_SIZE + dropAnimation,
                                    CELL_SIZE,
                                    tetrominoColors[currentPiece]
                                );
                            }
                        }
                    }
                }
            }

            context.restore();

            if (perfectClearTimer < perfectClearDuration && perfectClearText) {
                context.save();
                context.fillStyle = '#FF1493';
                context.font = 'bold 32px Arial';
                context.textAlign = 'center';
                const opacity = 1 - (perfectClearTimer / perfectClearDuration);
                context.globalAlpha = opacity;
                
                context.shadowColor = '#FF1493';
                context.shadowBlur = 20;
                context.fillText(perfectClearText, canvas.width / 2, canvas.height / 2 - 50);
                
                const hue = (perfectClearTimer / 50) % 360;
                context.fillStyle = `hsl(${hue}, 100%, 60%)`;
                context.shadowBlur = 10;
                context.fillText(perfectClearText, canvas.width / 2, canvas.height / 2 - 50);
                
                context.restore();
            }
            else if (tSpinTimer < tSpinDuration && tSpinText) {
                context.save();
                context.fillStyle = '#FFD700';
                context.font = 'bold 24px Arial';
                context.textAlign = 'left';
                const opacity = 1 - (tSpinTimer / tSpinDuration);
                context.globalAlpha = opacity;
                context.fillText(tSpinText, 10, canvas.height / 2);
                context.restore();
            }

            holdContext.clearRect(0, 0, holdCanvas.width, holdCanvas.height);
            if (heldPiece) {
                drawPiece(holdContext, heldPiece, 10, 10, 15);
            }

            nextContext.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
            for (let i = 0; i < Math.min(4, nextPieces.length); i++) {
                drawPiece(nextContext, nextPieces[i], 10, 10 + i * 70, 15);
            }

            document.getElementById('score').textContent = score;
            document.getElementById('level').textContent = level;
            document.getElementById('lines').textContent = linesCleared;
        }

        function update(currentTime) {
            if (!gameRunning) {
                requestAnimationFrame(update);
                return;
            }

            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            updateScreenShake(deltaTime);
            updateDropAnimation(deltaTime);
            updateRotationEffect(deltaTime);

            if (tSpinTimer < tSpinDuration) {
                tSpinTimer += deltaTime;
            }

            if (perfectClearTimer < perfectClearDuration) {
                perfectClearTimer += deltaTime;
            }

            if (currentPiece) {
                if (aiMode) {
                    aiMoveTimer += deltaTime;
                    if (aiMoveTimer >= aiMoveDelay) {
                        executeAIMove();
                        aiMoveTimer = 0;
                    }
                } else {
                    handleDAS(deltaTime);

                    dropTimer += deltaTime;
                    
                    if (keys.down) {
                        if (dropTimer >= 25) {
                            let dropCount = 0;
                            while (dropCount < 20 && movePiece(0, 1)) {
                                score += 1;
                                dropCount++;
                            }
                            dropTimer = 0;
                        }
                    } else if (dropTimer >= dropInterval) {
                        if (!movePiece(0, 1)) {
                            lockDelay += deltaTime;
                            if (lockDelay >= lockDelayMax) {
                                lockPiece();
                            }
                        } else {
                            lockDelay = 0;
                            moveResetCounter = 0;
                        }
                        dropTimer = 0;
                    }

                    if (isCollision(currentPiece, currentX, currentY + 1, currentRotation)) {
                        lockDelay += deltaTime;
                        if (lockDelay >= lockDelayMax) {
                            lockPiece();
                        }
                    }
                }
            }

            render();
            requestAnimationFrame(update);
        }

        function handleDAS(deltaTime) {
            const leftPressed = keys.left;
            const rightPressed = keys.right;
            
            if (leftPressed && rightPressed) {
                return;
            }
            
            if (leftPressed) {
                if (dasDirection !== -1) {
                    dasDirection = -1;
                    dasTimer = 0;
                    isFirstDasMove = true;
                    movePiece(-1, 0);
                } else {
                    dasTimer += deltaTime;
                    if (dasTimer >= dasDelay && isFirstDasMove) {
                        isFirstDasMove = false;
                        dasTimer = 0;
                    }
                    if (!isFirstDasMove && dasTimer >= arrRate) {
                        movePiece(-1, 0);
                        dasTimer = 0;
                    }
                }
            } else if (rightPressed) {
                if (dasDirection !== 1) {
                    dasDirection = 1;
                    dasTimer = 0;
                    isFirstDasMove = true;
                    movePiece(1, 0);
                } else {
                    dasTimer += deltaTime;
                    if (dasTimer >= dasDelay && isFirstDasMove) {
                        isFirstDasMove = false;
                        dasTimer = 0;
                    }
                    if (!isFirstDasMove && dasTimer >= arrRate) {
                        movePiece(1, 0);
                        dasTimer = 0;
                    }
                }
            } else {
                dasDirection = 0;
                dasTimer = 0;
                isFirstDasMove = true;
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.code === 'KeyF' && !keys.f) {
                keys.f = true;
                retryGame();
                e.preventDefault();
                return;
            }

            if (e.code === 'KeyI' && !keys.i) {
                keys.i = true;
                toggleAI();
                e.preventDefault();
                return;
            }

            if (!gameRunning || !currentPiece || aiMode) return;

            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = true;
                    e.preventDefault();
                    break;
                case 'ArrowRight':
                    keys.right = true;
                    e.preventDefault();
                    break;
                case 'ArrowDown':
                    keys.down = true;
                    e.preventDefault();
                    break;
                case 'ArrowUp':
                    if (!keys.up) {
                        hardDrop();
                        keys.up = true;
                    }
                    e.preventDefault();
                    break;
                case 'KeyZ':
                    if (!keys.z) {
                        tryRotate(-1);
                        keys.z = true;
                    }
                    e.preventDefault();
                    break;
                case 'KeyX':
                    if (!keys.x) {
                        tryRotate(1);
                        keys.x = true;
                    }
                    e.preventDefault();
                    break;
                case 'KeyC':
                    if (!keys.c) {
                        holdPiece();
                        keys.c = true;
                    }
                    e.preventDefault();
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    if (!keys.shift) {
                        try180Rotate();
                        keys.shift = true;
                    }
                    e.preventDefault();
                    break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'ArrowLeft':
                    keys.left = false;
                    break;
                case 'ArrowRight':
                    keys.right = false;
                    break;
                case 'ArrowDown':
                    keys.down = false;
                    break;
                case 'ArrowUp':
                    keys.up = false;
                    break;
                case 'KeyZ':
                    keys.z = false;
                    break;
                case 'KeyX':
                    keys.x = false;
                    break;
                case 'KeyC':
                    keys.c = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    keys.shift = false;
                    break;
                case 'KeyF':
                    keys.f = false;
                    break;
                case 'KeyI':
                    keys.i = false;
                    break;
            }
        });

        document.getElementById('aiToggle').addEventListener('click', toggleAI);

        initializeGame();
        requestAnimationFrame(update);
    </script>
</body>
</html>